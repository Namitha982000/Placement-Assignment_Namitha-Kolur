# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19QcZa_8CwY3168zfQzXBScaRda3BuPIT

# Question 8
"""

import torch
from torchvision.models.detection import detr
from torch.utils.data import DataLoader
from torchvision.transforms import ToTensor
from coco_utils import get_coco

# Define the dataset and data loader
train_dataset = get_coco("path/to/train/images", "path/to/train/annotations", transform=ToTensor())
train_loader = DataLoader(train_dataset, batch_size=16, shuffle=True)

# Initialize the DETR model
model = detr.__dict__["detr_resnet50"](num_classes=train_dataset.num_classes, pretrained=True)

# Define the loss function, optimizer, and learning rate scheduler
loss_fn = ...
optimizer = ...
lr_scheduler = ...

# Train the model
num_epochs = 10
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)

for epoch in range(num_epochs):
    for images, targets in train_loader:
        images = images.to(device)
        targets = [{k: v.to(device) for k, v in t.items()} for t in targets]

        # Forward pass
        outputs = model(images)
        loss_dict = model.criterion(outputs, targets)

        # Backward pass and optimization
        loss = sum(loss_dict.values())
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    # Update learning rate
    lr_scheduler.step()

    # Print training statistics
    print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}")

# Evaluate the model on the test set
test_dataset = get_coco("path/to/test/images", "path/to/test/annotations", transform=ToTensor())
test_loader = DataLoader(test_dataset, batch_size=1, shuffle=False)

model.eval()
for images, targets in test_loader:
    images = images.to(device)
    targets = [{k: v.to(device) for k, v in t.items()} for t in targets]

    # Forward pass
    outputs = model(images)

    # Process the outputs and generate predictions

    # Evaluate the predictions using metrics such as mAP or IoU

# Save the trained model
torch.save(model.state_dict(), "path/to/save/model.pth")